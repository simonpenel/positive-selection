<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title></title>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
  <!-- Latest compiled and minified CSS -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <!-- Optional theme -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">
  <!-- Latest compiled and minified JavaScript -->
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
  <script src='./d3.js' charset="utf-8"></script>
  <style media="screen">
    .node {
      cursor: pointer;
    }
    .block {
      cursor: pointer;
    }
    .cblock {
      cursor: none;
    }
    .slink {
      stroke: red;
      stroke-width: 10px;
      opacity: 0.3;
      fill: none;
    }
    .internal {
        font: 8px sans-serif;
    }
    div.tooltip {
      position: absolute;
      text-align: center;
      width:auto;
      height: auto;
      padding: 10px;
      font: 16px sans-serif;
      background: lightsteelblue;
      border: 10px;
      border-radius: 8px;
      pointer-events: none;
    }
    div.legend {
      position: absolute;
      text-align: left;
      width: 450px;
      height: 28px;
      padding: 2px;
      font: 24px sans-serif;
      border: 0px;
      border-radius: 8px;
      pointer-events: none;
    }
    div.dblegend {
      position: absolute;
      text-align: left;
      padding: 2px;
      font: 12px sans-serif;
      border: 2px;
      border-radius: 1px;
      pointer-events: none;
    }
    div.testnav {
      position: sticky;
      text-align: left;
      top:150px;
      left:50px;
      width: 250px;
      height: 28px;
      padding: 2px;
      font: 12px sans-serif;
      border: 0px;
      border-radius: 8px;
    }
    .testnav  a:hover {color:red;}
    div.demo {
      border: 3px solid #666;
      margin: 5px;
      padding: 5px;
      position: relative;
      width: 2500px;
      height: 1000px;
      overflow: auto;
    }
    .dropdown-menu {
      height: auto;
      max-height: 200px;
      overflow-x: hidden;
    }
  </style>
<% include ../partials/head %>
</head>
<body>
  <div class="demo">
    <nav class="navbar navbar-default navbar-fixed-top">

      <% include ../partials/header %>

      <!-- Bouton Display -->
      <div class="btn-group" id="display" >
        <button type="button" class="btn btn-default btn-sm dropdown-toggle" data-toggle="dropdown" data-toggle="tooltip" data-placement="top" title="Choose information to display" >
          Display
          <span class="caret"></span>
        </button>
        <ul class="dropdown-menu">
          <li id="nameSelection">
            <a href="#" class="small" data-value="name" tabIndex="-1"><input type="checkbox" id="name"/>&nbsp;Sequence Name</a>
          </li>
          <li><a href="#" class="small" data-value="species" tabIndex="-1"><input type="checkbox" id="species"/>&nbsp;Species Name</a></li>
          <li><a href="#" class="small" data-value="intname" tabIndex="-1"><input type="checkbox" id="intname"/>&nbsp;Node Support</a></li>
        </ul>
      </div>

      <!-- Division pour eventuel bouton crossref -->
      <div class="btn-group" id="crossref">
      </div>

      <!-- Bouton Action -->
      <div class="btn-group" role="group" id="action">
        <button type="button" class="btn btn-default btn-sm dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" data-toggle="tooltip" data-placement="top" title="Choose action on node"  >
          On click
          <span class="caret"></span>
        </button>
        <ul class="dropdown-menu">
          <li><a href="#" id="switch">Switch children</a></li>
          <li><a href="#" id="collapse">Collapse/Expand</a></li>
          <li><a href="#" id="subtree">Sub Tree/Upper Tree</a></li>
        </ul>
      </div>

      <!-- Bouton Collapse -->
      <button type="button" class="btn btn-default btn-sm" aria-label="Collapse" data-toggle="tooltip" data-placement="top" title="Collapse the tree" id="globalcollapse">
        <span>Compact tree</span>
      </button>

      <!-- Bouton Exapand all -->
      <button type="button" class="btn btn-default btn-sm" aria-label="Expand"  data-toggle="tooltip" data-placement="top" title="Expand the tree (takes time on big trees!)" id="globalexpand">
        <span>Expand tree</span>
      </button>

      <!-- Bouton Increase width -->
      <button type="button" class="btn btn-default btn-sm" aria-label="Left Align" id="moreWidth"  data-toggle="tooltip" data-placement="top" title="Increase tree width">
        <span>widthSize</span>
        <span class="glyphicon glyphicon-plus" aria-hidden="true"></span>
      </button>

      <!-- Bouton Reduce width -->
      <button type="button" class="btn btn-default  btn-sm  " aria-label="Left Align" id="lessWidth"  data-toggle="tooltip" data-placement="top" title="Reduce tree width">
        <span>widthSize</span>
        <span class="glyphicon glyphicon-minus" aria-hidden="true"></span>
      </button>

      <!-- Bouton Increase height -->
      <button type="button" class="btn btn-default btn-sm" aria-label="Left Align" id="moreHeigth"  data-toggle="tooltip" data-placement="top" title="Increase tree height">
        <span>heightSize</span>
        <span class="glyphicon glyphicon-plus" aria-hidden="true"></span>
      </button>

      <!-- Bouton Reduce height -->
      <button type="button" class="btn btn-default btn-sm" aria-label="Left Align" id="lessHeigth"  data-toggle="tooltip" data-placement="top" title="Reduce tree height">
        <span>heightSize</span>
        <span class="glyphicon glyphicon-minus" aria-hidden="true"></span>
      </button>

      <!-- Bouton Shift left -->
      <button type="button" class="btn btn-default btn-sm" aria-label="Left Align" id="goLeft"  data-toggle="tooltip" data-placement="top" title="Shift synteny left">
        <span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>
      </button>

      <!-- Bouton Shift right -->
      <button type="button" class="btn btn-default btn-sm" aria-label="Left Align" id="goRight" data-toggle="tooltip" data-placement="top" title="Shift synteny right">
        <span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span>
      </button>

      <!-- Bouton  Export -->
      <button type="button" class="btn btn-default btn-sm" aria-label="ExportSVG" id="export" data-toggle="tooltip" data-placement="top" title="Export the SVG">
        <span>Export SVG</span>
      </button>

  </nav>
  <div  class="testnav" id="testnav" ></div>
    <div class="">
      <svg></svg>
    </div>
  </div> <!-- <demo > -->
</body>
<script src="xmltree.js" charset="utf-8"></script>
<script src="layout.js" charset="utf-8"></script>
<script src="links.js" charset="utf-8"></script>
<script src="svgEvents.js" charset="utf-8"></script>
<script src='./speciestree/monarbre.js' charset="utf-8"></script>
<script src='./speciestree/palette.js' charset="utf-8"></script>
<!-- Code JS pour l'affichage de l'arbre  -->
<script type="text/javascript">

  // Recuperation des variables envoyee via Express
  // ----------------------------------------------
  var recTree = <%- arbre %>;
  var pattern  = <%- pattern %>;

  // Variables globales
  // ------------------
  var treeRoot;
  var cladeRoot;
  var layout = d3.layout.cladogram();   // Fonction  D3 qui transforme les donnees en cladograme
  var nodeWidth = 130;                  // Largeur
  var nodeHeigth = 30;                  // Hauteur
  var x0Synteny = 350;                  // Cordonee horizonatel de la syntenie
  var stringWidth ;                     // Largeur affichager arbre
  var tagSimpleGene = false;            // True si arbre de gene de type PhyloXML, False si arbre de gene de type RecPhyloXML
  var svg;                              // La div SVG
  var g;                                // Conteneur principal
  var diagonal = svgLinks.shoulder;     // cf links.js
  var symbol = d3.symbol().size(128);   // Symbol des noeuds
  var color = d3.scaleOrdinal(d3.schemeCategory20); // Echelle des couleurs
  var options ;                         // Options d'affichage
  var action;                           // Action assocue au click
  var selectedCrossref ;                // Reference croisée chhoisie ( nom de la sequence)
  var selectedCrossrefURL ;             // URL associé
  var crossref;                         // Objet  decrivant les differnetres  ref croisee associees a la famille
  var spattern=pattern.split('\n');     // pattern a chgerche et afficher dans l'arbre
  // Example getfam?fam=CLU_005912_4_2_C&pattern=0:PETMA_GL476433.PE1+0:ANOCA_6.PE486+1:XENTR_GL172641_1.PE38+1:XENTR_GL172642_1.PE97
  pattern=spattern;
  var patterns= [];
  var div;
  var myStorage = window.localStorage;    // utilisation de localStorage pour consrever les preferences

  if (!isStorageSupported(myStorage)) {
    console.log("window.localStorage problem");
    $(testnav).append('It seems that <b>window.localStorage</b> is full or is not supported by your browser<br>Please check this <a href="/clear/">here</a> ');
  }
  else {
    main_display();
  }

// Fonction d'affichage principale
// ------------------------------
function  main_display() {
  // Arbre d'especes (lu dans monarbre.js)
  var speciesTreeRoot = d3.hierarchy(cladeRootSpecies, function(d) {
    return d.clade;
  });
  // Transforme le tableau de [index:sequences] en tableau de tableau de [sequences].
  // a ameliorer, pas tres propre
  pattern.forEach(function(d,i){
    var buf = d.split(':');
    if (buf.length > 1){
      var indexPatt = buf[0];
      if (!patterns[indexPatt]){
        patterns[indexPatt]  = [];
      }
      patterns[indexPatt].push(buf[1]);
    }
    else {
      console.log("PATTERN ERROR : "+buf);
    }
  });
  // Test si l'arbre est du type
  // -recPhymloXML ( pas de distance, evenements de perte et transfert)
  // -phyloxml ()
  if (recTree.recGeneTree) {
    cladeRoot = recTree.recGeneTree.phylogeny.clade;
    // treeRoot = recTree.recGeneTree.phylogeny;
  }
  if (recTree.recPhylo) {
    cladeRoot = recTree.recPhylo.recGeneTree.phylogeny.clade;
    // treeRoot = recTree.recPhylo.recGeneTree.phylogeny;
  }
  if (recTree.phyloxml) {
    cladeRoot = recTree.phyloxml.phylogeny.clade;
    // treeRoot = recTree.phyloxml.phylogeny;
    tagSimpleGene = true;
  }
  // Affiche palette
  // ===============
  affichePalette();
  // Creation du SVG
  // ===============
  // Definit  la div tooltip
  div = d3.select("body").append("div")
    .attr("class", "tooltip")
    .style("opacity", 0);
  // Definit le svg
  svg = d3.select("svg");   // selectionne la div svg
  g = svg.append("g");      // ajoute element au svg
  var transition = d3.transition();
  margin = {
    top: 100,
    down: 20,
    left: 200,
    right: 300
  }
  // Option d'affichage
  stringOptions = myStorage.getItem("options");
  if (stringOptions === null || stringOptions === undefined || stringOptions === "undefined"){
    stringOptions = "name,species";
  }
  options = stringOptions.split(",");
  // Action associee au click
  action = svgEvents.switchChildren;
  var stringAction = myStorage.getItem("action");
  if ((stringAction === null )||(stringAction === undefined)||(stringAction === "undefined")){
    stringAction = "Collapse/Expand";
    myStorage.setItem("action",stringAction);
  }
  switch (myStorage.getItem("action")) {
    case "Switch children":
      action = svgEvents.switchChildren;
      break;
    case "Collapse/Expand":
      action = svgEvents.collapse;
      break;
    case "Sub Tree/Upper Tree":
      action = svgEvents.focus;
      break;
    default:
  }
  // Largeur de l'arbre
  if (tagSimpleGene === false) {
    nodeWidth = nodeWidth / 5 ;
  }
  stringWidth = myStorage.getItem("width");
  if ((stringWidth === null )||(stringWidth === undefined)||(stringWidth === "undefined")){
    stringWidth = nodeWidth;
    myStorage.setItem("width",stringWidth);
  }
  // Concerne les arbres recphyloxml
  var flatTreeConfig = {
    transferBack :false,
    speciationLoss : false,
    speciationOutLoss : false,
  }
  // Operation effectuee si il s'agt d'un arbre RecPhyloXML
  if (tagSimpleGene === false) {
    // cladeRoot est la racine hierarchisee en clade avec des modifs
    // specifiques aux arbres recPhyloXML
    cladeRoot =  xmlparser.flatTree(cladeRoot,flatTreeConfig);
  }
  var _cladeRoot = null;
  var _Parent = null;
  treeRoot = d3.hierarchy(cladeRoot, function(d) {
    return d.clade;
  });
  addNumberSeqSpec(treeRoot);
  updateLayout(cladeRoot,1);
}

// Definitions des fonctions
// ------------------------

// Fonction de test du support local.storage
// https://michalzalecki.com/why-using-localStorage-directly-is-a-bad-idea/
// ------------------------------------------
function isStorageSupported(storage) {
  try {
    const key = "__some_random_key_you_are_not_going_to_use__";
    storage.setItem(key, key);
  console.log(key),
  console.log(storage.getItem(key));
    storage.removeItem(key);
  console.log(storage.getItem(key));
    return true;
  } catch (e) {
    return false;
  }
}

// Fonction d'export du SVG
// ------------------------
function saveSVG(){
  // get styles from all required stylesheets
  // http://www.coffeegnome.net/converting-svg-to-png-with-canvg/
  var style = "\n";
  var requiredSheets = ['phylogram_d3.css', 'open_sans.css'];
  var img = new Image();
  var serializer = new XMLSerializer();
  // prepend style to svg
  svg.insert('defs',":first-child")
  d3.select("svg defs")
      .append('style')
      .attr('type','text/css')
      .html(style);
  var svgStr = serializer.serializeToString(svg.node());
  img.src = 'data:image/svg+xml;base64,'+window.btoa(unescape(encodeURIComponent(svgStr)));
  window.open().document.write('<p>Please copy or save the the image <img src="' + img.src + '"/>');
};

// Fonction recursive qui renvoie les noeuds ancestraux communs a
// une liste de feuilles
// ---------------------------------------------------------------
function recuAncestors (todo, done) {
  if (todo.length > 1) {
    var n1 = todo.shift();
    var n2 = todo.shift();
    var anc = n1.path(n2);
    var maxHeight=0;
    var n3=n1;
    anc.forEach(function (d ){
      if (d.height > maxHeight) {
        maxHeight = d.height;
        n3=d;
      }
    });
    todo.splice(0, 0,n3);
    done.push(n1);
    done.push(n2);
    anc = n1.path(n3);
    anc.forEach(function (d ){
      done.push(d)
    });
    anc = n2.path(n3);
    anc.forEach(function (d ){
      done.push(d)
    });
    return recuAncestors (todo, done)
  }
  else {
    var n1  = todo.shift();
    done.push(n1);
    return (done, [])
  }
}

//  Fonction de calcul du dernier ancetre commun (LCA)
//  --------------------------------------------------
function getLCASpecies(geneNode,speciesTree) {
    // Recupere les feuilles chez l'arbre de  genes
    var geneSpecies = [];
    var tmp = getSpec(geneNode);
    tmp.forEach(function(d){ geneSpecies.push(d.trim())});
    // Recupere les feuilles chez l'arbre d'especes qui sont
    //  dans l'arbre de genes
    var speciesTreeSelection = [];
    var speciesTreeLeaves =    speciesTree.descendants()
      .filter(function (e) {return !e.children});
    speciesTreeLeaves.forEach(function(d) {
      if (geneSpecies.includes(d.data.name.trim())) {
        speciesTreeSelection.push(d);
      }
    })
    //  Recupere le LCA des especes dans l'arbre d'especes
    var processed = [];
    var toprocess = speciesTreeSelection;
    recuAncestors(toprocess,processed);
    var hauteurMax = 0;
    var lca;
    processed.forEach(function (d){
      if (d) {
        if (d.height >=  hauteurMax) {
          hauteurMax = d.height;
          lca = d;
        }}
      });
    if (lca) {
      console.log("LCA = "+lca.data.name);
      return(lca.data.name);
    } else {
      console.log("ERROR UNABLE TO FIND LCA");
      return("Unknow L.C.A");
    }
  }

// Fonction d'affichage de la palette
// -----------------------------------
function affichePalette() {
  // Gestion de localStorage
  // var myStorage = window.localStorage;
  if (myStorage.getItem("ColorationProcessed") === null) {  // pas de coloration
    // Defintiion d'une palette
    // var selectedSpecies = "ARCHAEA::BECC43;EUKARYOTA::CC6096;BACTERIA::829863;BACTEROIDETES/CHLOROBI GROUP::18CCBA;BETAPROTEOBACTERIA::7C84CC;GAMMAPROTEOBACTERIA::2199CC;DELTA/EPSILON SUBDIVISIONS::CC667A;ALPHAPROTEOBACTERIA::BC97CC;FIRMICUTES::CC4A23;TENERICUTES::5849A3;ACTINOBACTERIA::F72D70;";
    var selectedSpecies = defaultPalette;
    myStorage.setItem("selectedSpecies",selectedSpecies);
    var allSpecies = [];
    var allSpeciesNoInternals = [];
    // Verification de la palette courante
    var selectedSpecArray =  selectedSpecies.split(";");
    var arrayLength = selectedSpecArray.length;
    var speciesPalette = [];
    var colorPalette = [];
    for (var i = 0; i < arrayLength-1; i++) {
      var specColor = selectedSpecArray[i].split("::");
      speciesPalette.push(specColor[0]);
      colorPalette.push(specColor[1]);
    }
    // Explore l'arbre d'espece pour fixer les couleurs des taxons
    var treeRoot = d3.hierarchy(cladeRootSpecies, function(d) {
      return d.clade;
    });
    treeRoot.eachBefore(function (d) {
      if (d.data.name.indexOf("(INTERNAL)") === -1) {
        allSpeciesNoInternals.push(d.data.name.trim());
      }
      allSpecies.push(d.data.name.trim());
      if  (speciesPalette.includes(d.data.name.trim())) {
        var index = speciesPalette.indexOf(d.data.name.trim());
        myStorage.setItem(d.data.name.trim(),"#"+colorPalette[index]);
        var nodes = d.descendants();
        nodes.forEach(function(n) {
          myStorage.setItem(n.data.name.trim(),"#"+colorPalette[index]);
          myStorage.setItem("phylum_"+n.data.name.trim(),speciesPalette[index]);
        });
      }
    });
    myStorage.setItem("ColorationProcessed","ok");
  }
  var selectedSpecies=myStorage.getItem("selectedSpecies");
  var selectedSpecArray =  selectedSpecies.split(";");
  var arrayLength = selectedSpecArray.length;
  $(testnav).append('<b>PALETTE:</b>');
  for (var i = 0; i < arrayLength-1; i++) {
    var specColor = selectedSpecArray[i].split("::");
    $(testnav).append('<div  style="color:#'+specColor[1]+'">'+specColor[0]+'</div>');
  }
  $(testnav).append('<a href=taxodico target=_blank>Edit</a>');
}

// Fonction de mise a jour de l'affichage
// ---------------------------------------
function updateLayout(cRoot,firstLoad=0) {
  var treeRoot = d3.hierarchy(cRoot, function(d) {
    return d.clade;
  });
  treeRoot.each(function (d) {
    var eventsRec = d.data.eventsRec;
    // Test si on a un noeud enrichi avec l'info eventsRec (type RecPhyloXML) ou non (type phyloxml)
    if (eventsRec){
      d.data.lastEvent = eventsRec[eventsRec.length - 1];
    }
    else {
      // Lors de la premiere lecture de l'arbre phyloxml, il n'y a pas de data.lastEvent defini aux noeuds
      // (Sauf les noeuds ecrases par la monophylie)
      // Mais ensuite ils sont definis : on choisit "speciation" meme si il ne s'agit pas d'une speciation en
      // realité, mais cela permet d'utiliser les code graphiques de speciation. eventType peut etre "speciation".
      // Par contre il ne doit plus etre   "collapsed" car c'est lie a la representation dans le DOM. Utiliser nodeinfo.status
      if (d.children) {
        if (!d.data.lastEvent) {
          d.data.lastEvent =  {eventType : "speciation"};
        }
      }
    }
  });
  layout.nodeSize([nodeWidth, nodeHeigth]);
  layout(treeRoot);
  // Traitement des distances dans le cas d'un arbre de gene de type phyloxml
  if (tagSimpleGene) {
    phylogeny(treeRoot,nodeWidth);
  } else {
    phylogeny_setloss(treeRoot,nodeWidth);
  }
  updateSvg(treeRoot,firstLoad);
}

// Fonction de coloration des feuilles
// -----------------------------------
function  setLeafColour (taxon){
  return myStorage.getItem(taxon.trim());
};

// Fonction de coloration du resultat d'une recherche de  pattern
// La variable pattern est ici un tableau du nom des feuilles qui ont matchés
// --------------------------------------------------------------------------
function subnode(nodes,pattern,colPattern) {
  var ancs;
  var n1;
  var n2;
  var n3;
  var selection = [];
  var racine = null;
  // Selection des feuilles
  var scrollref = 0;
  nodes.forEach(function (d,i ){
    if (d.depth == 0) {
      racine = d;
    }
    if (d.data.lastEvent.crossref) {
      // Si la balise crossref est presente on
      // l'utilise plutot que le nom du gene
      var cross=d.data.lastEvent.crossref;
      for(var exKey in cross) {
        var nomFeuille = cross[exKey];
        pattern.forEach(function (p){
          var nomPattern = p.replace(/[\n\r]/g, '');
          if (nomFeuille === nomPattern) {
            selection.push(d);
            scrollref=d.y;
          }
        })
      }
    }
    if (d.data.name){
      var nomFeuille = d.data.name;
      pattern.forEach(function (p){
        var nomPattern = p.replace(/[\n\r]/g, '');
        if (nomFeuille === nomPattern) {
          selection.push(d);
          scrollref=d.y;
          if (!d.data.lastEvent["pattern"]) {
            d.data.lastEvent["pattern"] = [];
            }
            d.data.lastEvent["pattern"].push(colPattern); // un noeud peut etre associe a plusieur palettes
        }
      })
    }
    var tmp =   removeDuplicates(selection);
    selection = tmp;
  });
  var processed = [];
  if (selection.length == 1) {
    selection.push(racine);
  }
  var toprocess = selection;
  recuAncestors(toprocess,processed);
  var ancestors = processed;
  nodes.forEach(function (d ){
    if (ancestors.includes(d)) {
      if (!d.data.lastEvent["pattern"]) {
        d.data.lastEvent["pattern"] = [];
      }
      d.data.lastEvent["pattern"].push(colPattern); // un noeud peut etre associe a plusieur palettes
    }
  });
  return scrollref;
}

// Fonction de calcul de la position  d'un noeud a partir des longueurs
// de branch_length
// --------------------------------------------------------------------
function phylo(n) {
  var dist = 0.0;
  if (n && n.data.branch_length != null) {
    var p = n.parent;
    dist = parseFloat(n.data.branch_length) + phylo(p);
    return dist;
  }
  return dist;
}

// Fonction pour utiliser les lobgueurs de branchede lors de l'affichage
// d'un arbre
// ----------------------------------------------------------------------
function phylogeny(treeRoot,offset) {
  treeRoot.each(function (d) {
    var phylodist = phylo(d);
    d.x = phylodist*offset;
  });
}

// Fonction qui decale la position x d'un "loss"
// ---------------------------------------------
function phylogeny_setloss(treeRoot,offset) {
  treeRoot.each(function (d) {
    if (d.data.lastEvent.eventType === "loss") {
     var lospar = d.parent;
     d.x = (d.x+lospar.x)/2
    }
  });
}

// Fonction pour savoir si un noeud est monophyletique en terme de coleur
// ----------------------------------------------------------------------
function monophyletic(noeud) {
  var monoNodes = noeud.descendants();
  var monoLeaves = monoNodes.filter(function (e) {
    return !e.children;
  });
  d=monoLeaves[0];
  var eventsRec = d.data.eventsRec;
  if (eventsRec){
    var lastEvent = eventsRec[eventsRec.length - 1];
  }
  var monoColour = setLeafColour(lastEvent.speciesLocation);
  var isMono = [lastEvent.speciesLocation,monoLeaves.length];
  var speciesLeaves = [];
  var anc = monoLeaves[0];
  monoLeaves.forEach(function (d) {
    eventsRec = d.data.eventsRec;
    if (eventsRec){
      var lastEvent = eventsRec[eventsRec.length - 1];
    }
    speciesLeaves.push(lastEvent.speciesLocation);
    if (setLeafColour(lastEvent.speciesLocation) !=  monoColour) {
      var newanc = anc.path(d);
      anc = newanc[0];
      isMono = [0,0];
    }
  });
  var unicSpecies = removeDuplicates(speciesLeaves);
  isMono.push(unicSpecies.length);
  return(isMono)
}

// Fonction qui collaopse les noeuds monophyletiques situes entre une certaine
// hauteur de la racine et une  certaine hauteur des noeuds deja collapses
// ------------------------------------------------------------------------
function collapseMonophyletic(treeRoot,patterns) {
  var acolapser = [];
  var aouvrir = [];
  var prevnode = null;
  if (patterns.length > 0 ) {
    // Boucle sur les patterns
    patterns.forEach(function(p){
      // Selection des feuilles
      p.forEach(function (d,i ){
        var nomPattern= d.replace(/[\n\r]/g, '');
        var focusNode = null;
        // Recupere la feuille focus
        treeRoot.each(function (d,i ){
          if (d.data.name){
            var nomFeuille = d.data.name;
            if (nomFeuille === nomPattern) {
              focusNode = d;
            }
          }
          // cas des crossref
          if (d.data.eventsRec) {
            if (d.data.eventsRec[0].crossref) {
              // Si la balise crossref est presente on
              // l'utilise plutot que le nom du gene
              var cross=d.data.eventsRec[0].crossref;
              for(var exKey in cross) {
                var nomFeuille = cross[exKey];
                if (nomFeuille === nomPattern){
                  console.log("FIND PATTERN "+nomFeuille);
                  focusNode = d;
                }
              }
            }
          }
        });
        if (focusNode) {
          //Ouvre les freres de la feuille
          parent = focusNode.parent;
          parent.each(function (d) {
            // aouvrir.push(d)
          });
          //ouvre les noeuds entre la feuille et la racine
          while (parent != null) {
            aouvrir.push(parent)
            parent = parent.parent;
          }
        }
        else {
          console.log("PATTERN NOT FOUND: "+ nomPattern);
        }
      });
    });
  }
  else {
    console.log("NO PATTERN SEARCH");
  }
  treeRoot.eachBefore(function (d) {
    var parent = d.parent;
    var gparent = parent;
    if (gparent !== null) {
      gparent = parent.parent;
    }
    var agparent = gparent;
    if (agparent !== null) {
      agparent = gparent.parent;
    }
    var aagparent = agparent;
    if (aagparent !== null) {
      aagparent = agparent.parent;
    }
    var aaagparent = aagparent;
    if (aaagparent !== null) {
      aaagparent = aagparent.parent;
    }
    if (!(( aouvrir.includes(d)) ||( acolapser.includes(parent)) ||  (acolapser.includes(gparent))||  (acolapser.includes(agparent))||  (acolapser.includes(aagparent)) )){
      var monoTest = monophyletic(d);
      if (monoTest[0] != 0) {
        acolapser.push(d);
        if (d.depth > 0) {
          var phylum = setLeafColour("phylum_"+monoTest[0]);
          var phylum = getLCASpecies(d,speciesTreeRoot);
          if (!phylum) {
            phylum = "Undefined"
          }
          if   (d.data.clade) {
            // d.data.name = "["+monoTest[1]+" seq "+monoTest[2]+" spe] ";
            // d.data.lastEvent = {eventType : "collapsed", speciesLocation :phylum};
            // Un peu bizzare de donner monophyletic comme eventype
            // On est oblige de faire ca car on ecrase les noeuds avant de faire le updatelyaout qui va justement
            // ajourter les   d.data.lastEvent
            if (! d.data.lastEvent) { // je  ne veux pas ecraser l'info si elle existe deja
              d.data.lastEvent = {eventType : "monophyletic",speciesLocation :phylum};
            }
            // d.data.lastEvent.speciesLocation = phylum;
            d.data.nodeinfo = {status : "collapsed"};
            d.data._clade = d.data.clade;
            d.data.clade = null;
          }
        }
      }
    }
  });
}

// Fonction qui collaopse les noeuds monophyletiques situes entre une certaine
// hauteur de la racine et une  certaine hauteur des noeuds deja collapses
// pour les gros arbres
// ------------------------------------------------------------------------
function collapseMonophyleticBigTree(treeRoot,patterns) {
  var acolapser = [];
  var aouvrir = [];
  var prevnode = null;
  if (patterns.length > 0 ) {
    // Boucle sur les patterns
    patterns.forEach(function(p){
      // Selection des feuilles
      p.forEach(function (d,i ){
        var nomPattern= d.replace(/[\n\r]/g, '');
        var focusNode = null;
        // Recupere la feuille focus
        treeRoot.each(function (d,i ){
          if (d.data.name){
            var nomFeuille = d.data.name;
            if (nomFeuille === nomPattern) {
              focusNode = d;
            }
          }
          // cas des crossref
          if (d.data.eventsRec) {
            if (d.data.eventsRec[0].crossref) {
              // Si la balise crossref est presente on
              // l'utilise plutot que le nom du gene
              var cross=d.data.eventsRec[0].crossref;
              for(var exKey in cross) {
                var nomFeuille = cross[exKey];
                if (nomFeuille === nomPattern){
                  console.log("FIND PATTERN "+nomFeuille);
                  focusNode = d;
                }
              }
            }
          }
        });
        if (focusNode) {
          //Ouvre les freres de la feuille
          parent = focusNode.parent;
          parent.each(function (d) {
            // aouvrir.push(d)
          });
          //ouvre les noeuds entre la feuille et la racine
          while (parent != null) {
            aouvrir.push(parent)
            parent = parent.parent;
          }
        }
        else {
          console.log("PATTERN NOT FOUND: "+ nomPattern);
        }
      });
    });
  }
  else {
    console.log("NO PATTERN SEARCH");
  }
  treeRoot.eachBefore(function (d) {
    var parent = d.parent;
    var gparent = parent;
    if (gparent !== null) {
      gparent = parent.parent;
    }
    var agparent = gparent;
    if (agparent !== null) {
      agparent = gparent.parent;
    }
    var aagparent = agparent;
    if (aagparent !== null) {
      aagparent = agparent.parent;
    }
    var aaagparent = aagparent;
    if (aaagparent !== null) {
      aaagparent = aagparent.parent;
    }
    if (!(( aouvrir.includes(d)) ||( acolapser.includes(parent)) ||  (acolapser.includes(gparent))||  (acolapser.includes(agparent))||  (acolapser.includes(aagparent)) )){
      // if (d.depth % 3 == 0 ){
      // var monoTest = monophyletic(d);
      var monoTest =[1,1];
      // if (d.depth < 5 ) {
      //   monoTest = monophyletic(d);
      // }
      // if (monoTest[0] != 0) {
      acolapser.push(d);
      if (d.depth > 0) {
        var phylum;
        if (d.depth < 10 ) {
          monoTest = monophyletic(d);
          phylum = setLeafColour("phylum_"+monoTest[0]);
        }
        if (!phylum) {
          phylum = "Undetermined taxon"
        }
        if   (d.data.clade) {
          // d.data.name = "["+monoTest[1]+" seq "+monoTest[2]+" spe] ";
          // d.data.lastEvent = {eventType : "collapsed", speciesLocation :phylum};
          // Un peu bizzare de donner monophyletic comme eventype
          // On est oblige de faire ca car on ecrase les noeuds avant de faire le updatelyaout qui va justement
          // ajourter les   d.data.lastEvent
          if (phylum  != "Undetermined taxon") {
            if (! d.data.lastEvent) { // je  ne veux pas ecraser l'info si elle existe deja
            d.data.lastEvent = {eventType : "monophyletic",speciesLocation :phylum};
            }
          }
          else {
            if (! d.data.lastEvent) { // je  ne veux pas ecraser l'info si elle existe deja
              d.data.lastEvent = {eventType : "speciation",speciesLocation :phylum};
            }
          }
          d.data.lastEvent.speciesLocation = phylum;
          d.data.nodeinfo = {status : "collapsed"};
          d.data._clade = d.data.clade;
          d.data.clade = null;
        }
      }
    }
  });
}

// Fonction ajoute nb sequences et especes
// ---------------------------------------
function  addNumberSeqSpec(treeRoot) {
  treeRoot.eachAfter(function (d) {
    var specs = [];
    if (!d.children) {
      d.data.nbseqspe =  {nbSeq : 1,nbSpe : 1};
    }
    else {
      var nbseq = 0;
      var nbspe = 0;
      var fils = d.children;
      fils.forEach(function (d){
        nbseq = nbseq + d.data.nbseqspe.nbSeq;
        // nbspe = nbspe + d.data.nbseqspe.nbSpe;
        var spec = getSpec(d);
        specs = specs.concat(spec);
      })
      var tmp = specs;
      uspecs=removeDuplicates(tmp);
      nbspe=uspecs.length;
      d.data.nbseqspe =  {nbSeq :nbseq,nbSpe :nbspe};
    }
  });
}

// Fonction recupere especes
// -------------------------
function getSpec (noeud) {
  if (!noeud.children) {
    var specs = [];
    var eventsRec = noeud.data.eventsRec;
    if (eventsRec) {
      var lastEvent = eventsRec[eventsRec.length - 1];
      specs.push(lastEvent.speciesLocation)
    }
    else {
      console.log(" ERROR : NO EVENTS FOR ");
      console.log(noeud.data);
    }
    return specs;
  }
  else {
    var specs = [];
    var fils = noeud.children;
      fils.forEach(function (d, i ){
        var spec = getSpec(d);
        var tmp = specs.concat(spec);
        specs = tmp;
      });
    return specs;
  }
}

// Fonction qui collapse les noeuds d'une certaine profondeur
// ----------------------------------------------------------
function expandTree(treeRoot) {
  treeRoot.each(function (d) {
    if (d.data.nodeinfo) {
      if (d.data.nodeinfo.status === "collapsed") {
        if (d.data._clade) {
          d.data.clade = d.data._clade;
          d.data._clade = null;
          d.data.nodeinfo = {status : "extended"};
        }
      }
    }
  });
}

// Fonction qui collapse les noeuds d'une certaine profondeur
// ----------------------------------------------------------
function collapseVeryBigTree(treeRoot,patterns) {
  var acolapser = [];
  var aouvrir = [];
  if (patterns.length > 0)  {
    //Ecrase tous les noeuds
    treeRoot.each(function (d) {
      if ((d.depth == 5) || (d.depth == 10) ||(d.depth == 20)|| (d.depth == 30)|| (d.depth == 40) ) {
      acolapser.push(d)
      }
    });
    // Boucle sur les patterns
    patterns.forEach(function(p) {
      // Selection des feuilles de la pattern
      p.forEach(function(d,i) {
        var nomPattern= d.replace(/[\n\r]/g, '');
        var focusNode = null;
        // Recupere la feuille focus
        treeRoot.each(function (d,i ){
          if (d.data.name){
            var nomFeuille = d.data.name;
            if (nomFeuille === nomPattern) {
              focusNode = d;
            }
          }
          // cas des crossref
          if (d.data.eventsRec) {
            if (d.data.eventsRec[0].crossref) {
              // Si la balise crossref est presente on
              // l'utilise plutot que le nom du gene
              var cross=d.data.eventsRec[0].crossref;
              for(var exKey in cross) {
                var nomFeuille = cross[exKey];
                if (nomFeuille === nomPattern){
                  console.log("FIND PATTERN "+nomFeuille);
                  focusNode = d;
                }
              }
            }
          }
        });
        if (focusNode) {
          var parent = focusNode.parent;
          //Ouvre les freres de la feuille
          parent.each(function (d) {
            // aouvrir.push(d)
          });
          //ouvre les noeuds entre la feuille et la racine
          while (parent != null) {
            aouvrir.push(parent)
            parent = parent.parent;
          }
        }
        else {
          console.log("PATTERN NOT FOUND : "+nomPattern);
        }
      });
    });
  }
  else {
    console.log("NO PATTERN")
    treeRoot.each(function (d) {
      if ((d.depth == 5) || (d.depth == 10) ||(d.depth == 30)|| (d.depth == 60)|| (d.depth == 90) ) {
        acolapser.push(d)
      }
    });
  }
  acolapser.forEach(function (d) {
    if   (d.data.clade) {
      d.data._clade = d.data.clade;
      d.data.clade = null;
      d.data.nodeinfo = {status : "collapsed"};
    }
  });
  aouvrir.forEach(function (d) {
    if   (d.data._clade) {
      d.data.clade = d.data._clade;
      d.data._clade = null;
      d.data.nodeinfo = {status : "extended"};
    }
  });
}

  // Fonction  suppression d'un element unique dans un tableau
  // ----------------------------------------------------------
  function removeSingle(target_array) {
    target_array.sort();
    var i = 0;
    while(i < target_array.length) {
      if(target_array[i] !== target_array[i+1]) {
        target_array.splice(i,1);
      }
      else {
        i += 1;
      }
    }
    return target_array;
  }

  // Fonction  suppression des  elements multiples dans un tableau
  // --------------------------------------------------------------
  function removeDuplicates(target_array) {
    target_array.sort();
    var i = 0;
    while(i < target_array.length) {
      if(target_array[i] === target_array[i+1]) {
        target_array.splice(i+1,1);
      }
      else {
        i += 1;
      }
    }
    return target_array;
  }

  // Fonction  suppression des  elements multiples dans un tableau et classe par occurence
  // -------------------------------------------------------------------------------------
  function removesortDuplicates(target_array) {
    target_array.sort();
    var sorted_array = [];
    var i = 0;
    var j = 0;
    var vscore  = {score: 0, fam: "none"};
    var scored_array = [];
    var score = [];
    score[j] = 0;
    sorted_array[i] = target_array[i];
    i=1;
    while(i < target_array.length) {
      if(target_array[i] !==  sorted_array[j]) {
        j = j + 1;
        sorted_array[j] = target_array[i];
        score[j] = 0;
      } else {
         score[j] = score[j] + 1;
      }
       i = i + 1;
    }
    i = 0;
    while(i <= j){
      vscore  = {score: score[i], fam: sorted_array[i]};
      scored_array.push(vscore);
      i = i + 1
    }
    console.log(scored_array);
    scored_array.sort(function(a,b){
          scA=a.score;
          scB=b.score;
          console.log("CLASSEMENT ["+scA+"] ["+scB+"]=");
          return scB - scA;
        });
    i = 0;
    while(i <= j){
      sorted_array[i] = scored_array[i].fam;
      i = i + 1
    }
    return sorted_array;
  }

// Fonction principale : mise a jour du svg
// ----------------------------------------
function updateSvg(treeRoot,firstLoad  ,config = {}) {
  var scrollref=0;
  var configLayout = {
    layout : config.layout || "cladogramSpecial",
    links : config.links || "shoulder",
    symbolSize : config.symbolSize || 128,
    lengthLinkLoss : config.lengthLinkLoss || 10,
    linkStrokeSize : config.linkStrokeSize || 2,
    nodeWidth : config.nodeWidth || 30,
    nodeHeigth : config.nodeHeigth || 30,
    margin : config.margin || { top: 10, down: 20, left: 500  , right: 50},
    color : config.color || {
      speciation : "#2F4F4F",
      speciationOutLoss : "#2CA02C",
      branchingOut : "#D62728",
      speciationOut : "#2CA02C",
      bifurcationOut : "#000000",
      transferBack : "#D62728",
      duplication : "#9467BD",
      speciationLoss : "#1F77B4",
      leaf : "#FF7F0E",
      loss : "#000000"
    },
    symbols : config.symbols || {
      speciation : "symbolCircle",
      collapsed : "symbolCircle",
      speciationOutLoss : "symbolCircle",
      branchingOut : "symbolSquare",
      speciationOut : "symbolCircle",
      bifurcationOut : "symbolCircle",
      transferBack : "symbolDiamond",
      duplication : "symbolSquare",
      speciationLoss : "symbolCircle"
    }
  }
  var nodes = treeRoot.descendants();
  var links = treeRoot.links();
  // Coloration du pattern si il existe
  if ((pattern != "none") && (pattern !== ' ') && (pattern !== undefined)) {
    // Boucle sur les differents patterns
    patterns.forEach(function (d,i) {
      // Traite le pattern d avec comme index i
      // var subNodes = subnode(nodes,d,i);
      scrollref = subnode(nodes,d,i);
    });
  }
  var minX = d3.min(nodes, function(d) {
    return d.x;
  });
  var maxX = d3.max(nodes, function(d) {
    return d.x;
  });
  var widthSVG = maxX - minX;
  var minY = d3.min(nodes, function(d) {
    return d.y;
  });
  var maxY = d3.max(nodes, function(d) {
    return d.y;
  });
  var heightSVG = maxY - minY;
  svg.attr("width", widthSVG + margin.right + margin.left+1600);
  svg.attr("height", heightSVG + margin.top + margin.down+200);
  g.attr("transform", "translate(" + (margin.right - minX) + "," + (margin.top - minY) + ")")
  // ====================
  //  D3: Objets LINK
  // ====================
  var link = g.selectAll(".link").data(links);  // associe l'element link a la donnee links
  //EXIT gere les elements qui ont disparu
  link.exit().remove();
  //ENTER gere les elements nouveaux
  var linkEnter =
    link
    .enter()
    .append("path")
    .attr("class", "link");
  linkEnter
    .merge(link)  // fusionne les nouveaux elements avec les anciens
    .attr("fill","none")
    .attr("stroke-width",configLayout.linkStrokeSize)
    .attr("stroke",function (d) {
      if (d.target.data.lastEvent !== undefined) {
        var pa = d.target.data.lastEvent.pattern;
        if (pa !== undefined) {
          return "red";
        }
      }
      if(d.target.data.deadSpecies)
        {
          return "#fff";
        }
      else {
        return "#0e2e2e";
      }
    })
    .on('mouseover',function (d){
      var pattIndex =  d.target.data.lastEvent.pattern;
      if (pattIndex !== undefined) {
        var sel1 =g.selectAll(".link").filter(function(e) {
          var pa = e.target.data.lastEvent.pattern;
          if (pa !== undefined) {
            // pa est le tableau des index des pattern  associee au noeud
            // pattIndex[0] est l'index de la pattern  associee au noeud survole
            return (pa.indexOf(pattIndex[0]) > -1)
          }
          return (false)
        });
        sel1.style("stroke-width","10")
      }
    })
    .on('mouseout',function (d){
      var pattIndex =  d.target.data.lastEvent.pattern;
      if (pattIndex !== undefined) {
        var sel1 =g.selectAll(".link").filter(function(e) {
          var pa = e.target.data.lastEvent.pattern;
          if (pa !== undefined) {
            // pa est le tableau des index des pattern  associee au noeud
            // pattIndex[0] est l'index de la pattern  associee au noeud survole
            return (pa.indexOf(pattIndex[0]) > -1)
          }
          return (false)
        });
        sel1.style("stroke-width",configLayout.linkStrokeSize)
      }
    })
    .attr("d", diagonal)
    .attr('stroke-dasharray',function(d){
      var et = d.target.data.lastEvent.eventType;
      var sl = d.target.data.lastEvent.speciesLocation;
      if (et === "transferBack" || et === "bifurcationOut" || sl == "Out") return '5,5';
    });
  // ====================
  // D3:  Objets NODE
  // ====================
  var node = g.selectAll(".node").data(nodes);
  //EXIT
  node.exit().remove();
  //ENTER
  var nodeEnter =
    node
    .enter()
    .append("g")
    .attr("class", "node");
  nodeEnter
    .append("g")
    .attr("class", "gsymbol")
    .append("path")
    .attr("class", "symbol");
  nodeEnter
    .append("text")
    .attr("class", "label")
    .on("click", function(d) {
      if (d.data.lastEvent.crossref) {
        // Si la balise crossref est presente on fait un lien vers l'url
        // qui requete l'identifiant dans la base de donnees selectionnee
        var cross=d.data.lastEvent.crossref;
        if (selectedCrossref !== null) {
          name = cross[selectedCrossref];
          url = selectedCrossrefURL.replace("IDENTIFIANT",name);
        }
        window.open(url);
      }
    });
  nodeEnter
    .append("text")
    .attr("class", "internal");
  //ENTER + UPDATE
  var allNodes =
    nodeEnter
    .merge(node)
    .attr("transform", function(d) {
      if (d.data.lastEvent.eventType === "loss") {
        return "translate(" + [d.x, d.y] + ")";
      }
      else {
        return "translate(" + [d.x, d.y] + ")";
      }
    })
    .on("click",action);
  allNodes
    .select(".gsymbol")
    .attr("transform", function(d) {
      var str = "";
      if (d.data.lastEvent.eventType === "loss") {
        str += "rotate(45)";
      }
      if (d.data.lastEvent.eventType === "leaf")  {
        str += "rotate(90)";
      } else {
        str += "";
      }
      return str;
    });
  allNodes
    .select(".symbol")
    .attr("fill", function(d) {//Couleur de remplissage  du symbol
      switch (d.data.lastEvent.eventType) {
        case "monophyletic":
          return setLeafColour(d.data.lastEvent.speciesLocation);
          break;
        case "speciation":
          return configLayout.color.speciation
          break;
        case "speciationOutLoss":
          return configLayout.color.speciationOutLoss
          break;
        case "branchingOut":
          return configLayout.color.branchingOut
          break;
        case "speciationOut":
          return configLayout.color.speciationOut
          break;
        case "bifurcationOut":
          return configLayout.color.bifurcationOut
          break;
        case "transferBack":
          return configLayout.color.transferBack
          break;
        case "duplication":
          return configLayout.color.duplication
          break;
        case "speciationLoss":
          return configLayout.color.speciationLoss
          break;
        case "leaf":
          return setLeafColour(d.data.lastEvent.speciesLocation);
          break;
        case "loss":
          return configLayout.color.loss
          break;
        default:
        }
      })
    .attr("d", function(d) { //Type de symbol
       // Verification si le noeud est collapse
      if (d.data.nodeinfo) {
          if (d.data.nodeinfo.status === "collapsed") {
            return symbol.type(d3.symbolCircle)()
          }
      }
      switch (d.data.lastEvent.eventType) {
        case "monophyletic":          // cas ou le noeud monophyletic n'est pas pas collapse
          return symbol.type(d3[configLayout.symbols.speciation])()
          break;
        case "speciation":
          return symbol.type(d3[configLayout.symbols.speciation])()
          break;
        case "speciationOutLoss":
          return symbol.type(d3[configLayout.symbols.speciationOutLoss])()
          break;
        case "branchingOut":
          return symbol.type(d3[configLayout.symbols.branchingOut])()
          break;
        case "speciationOut":
          return symbol.type(d3[configLayout.symbols.speciationOut])()
          break;
        case "bifurcationOut":
          return symbol.type(d3[configLayout.symbols.bifurcationOut])()
          break;
        case "transferBack":
          return symbol.type(d3[configLayout.symbols.transferBack])()
          break;
        case "duplication":
          return symbol.type(d3[configLayout.symbols.duplication])()
          break;
        case "speciationLoss":
          return symbol.type(d3[configLayout.symbols.speciationLoss])()
          break;
        case "leaf":
          return symbol.type(d3.symbolTriangle)()
          break;
        case "loss":
          return symbol.type(d3.symbolCross)()
        default:
      }
    })
    .attr("stroke-width", "0px")
    .filter(function (d) {
       return d.data._clade? true : false;
    })
    .attr("fill", "white")
    .attr("stroke-width", "2px")
    .attr("stroke", function(d) {   //Couleur de trait du symbol
      switch (d.data.lastEvent.eventType) {
        case "speciation":
          return configLayout.color.speciation
          break;
        case "speciationOutLoss":
          return configLayout.color.speciationOutLoss
          break;
        case "speciationOut":
          return configLayout.color.speciationOut
          break;
        case "bifurcationOut":
          return configLayout.color.bifurcationOut
          break;
        case "transferBack":
          return configLayout.color.transferBack
          break;
        case "duplication":
          return configLayout.color.duplication
          break;
        case "speciationLoss":
          return configLayout.color.speciationLoss
          break;
        case "leaf":
          return configLayout.color.leaf
          break;
        case "monophyletic":
          // return configLayout.color.leaf
          return setLeafColour(d.data.lastEvent.speciesLocation)
          break;
        case "loss":
          return configLayout.color.loss
          break;
        default:
      }
    });
  allNodes
    .select(".label")
    .transition()
    .attr("y", function(d) {
      return d.children ? -8 : 3;
    })
    .attr("x", function(d) {
      return d.children ? -8 : 8;
    })
    .style("text-anchor", function(d) {
      return d.children ? "end" : "start";
    })
    .text(function(d) {
      var name = "";
      if (d.data.nodeinfo) {
        if (d.data.nodeinfo.status === "collapsed") {
            name += "seq:"+d.data.nbseqspe.nbSeq + " spe:"+d.data.nbseqspe.nbSpe;
        }
      }
      if (d.data.name && options.includes("name") && d.data.lastEvent.eventType === "leaf") {
        if (d.data.lastEvent.crossref) {
          var cross=d.data.lastEvent.crossref;
          if (selectedCrossref !== null) {
            name += cross[selectedCrossref];
          }
        }
        else {
          name += (d.data.name || d.data.lastEvent.geneName);
        }
        if (d.data.lastEvent.pattern !==undefined) {
          name = ">>>>"+name+"<<<<";
        }
      }
      if (options.includes("species")&& d.data.lastEvent.eventType === "leaf") {
        name += " " + d.data.lastEvent.speciesLocation.replace("(INTERNAL)","") ;
      }
      if (options.includes("species")&& d.data.lastEvent.eventType === "monophyletic") {
        name += " " + d.data.lastEvent.speciesLocation.replace("(INTERNAL)","") ;
      }
      if (d.data.lastEvent.destinationSpecies) {
        name += " ( -> " + d.data.lastEvent.destinationSpecies + ")";
      }
      return name;
    })
    .style("fill",function (d) {
      if (d.data.name && d.data.lastEvent.eventType === "leaf") {
        return setLeafColour(d.data.lastEvent.speciesLocation);
      }
      if (d.data.name && d.data.lastEvent.eventType === "monophyletic") {
        return setLeafColour(d.data.lastEvent.speciesLocation);
      }
    })
    .style("font-family","sans-serif")
    .style("font-size","12px")
    .style("font-weight","bold")
    .style("text-decoration",function (d) {
      var pa = d.data.lastEvent.pattern;
      if (pa != undefined) {
        return "wavy underline overline";
      }
      else return "none";
    });
  allNodes
    .select(".internal")
    .transition()
    .attr("y", 10)
    .attr("x", -10)
    .style("text-anchor","end")
    .text(function(d) {
      var name = "";
      if (options.includes("intname")) {
        if (d.data.confidence) {
          var name = d.data.confidence._text;
        }
      }
      return name
    });
  // =======================
  // Selection des feuilles
  // =======================
  var leaves = nodes.filter(function (e) {
      return !e.children;
    });
  // ==============================================================
  // Selection les feuilles qui presentent des sythenies a  gauche
  // ==============================================================
  var synteleaves = leaves.filter(function (d) {return(d.data.lastEvent.syntenyLeft)});
  var numberMaxFam = 0;
  synteleaves.forEach (function (d,i ){
    var synteny = d.data.lastEvent.syntenyLeft ;
    var fams =  synteny.split(/\s+/);
    var numberFam = 0;
    fams.forEach (function (d,i){
       numberFam ++;
    })
    if (numberFam > numberMaxFam) {
      numberMaxFam = numberFam;
    }
  });
  // creation d'un jeu de donnees pour les blocs de sythenie
  var dataset = [];
  var families = [];
  var centralDataset = [];
  synteleaves.forEach (function (d,i ){
    var synteny = d.data.lastEvent.syntenyLeft ;
    var fams =  synteny.split(/\s+/);
    var xfam = d.x;
    xfam = x0Synteny+maxX + 40*numberMaxFam ;
    var yfam = d.y-10;  // a amelioreril faudrait la moitie de l'epaisseur du pollinyne
    var nfam = "fam";
    fams.forEach (function (d,i){
      var famcds = d.split(/:/);
      var nomFam = famcds[0];
      var cds = "none";
      if (famcds.length > 0) {
        cds = famcds[1];
      }
      var sens = 1;
      if (nomFam.substring(0,1) === "-") {
        sens = -1;
        nomFam = nomFam.substring(1);
      };
      if (nomFam.substring(0,1) === "+") {
        nomFam = nomFam.substring(1);
      };
      var locnode = {x:xfam - i*40,y: yfam,nfam:nomFam,sens:sens,cds:cds};
      dataset.push(locnode);
      families.push(nomFam);
    });
   });
  // =============================================================
  // Selection les feuilles qui presentent des sythenies a  droite
  // =============================================================
  synteleaves = leaves.filter(function (d) {return(d.data.lastEvent.syntenyRight)});
  synteleaves.forEach (function (d,i ){
    var synteny = d.data.lastEvent.syntenyRight ;
    var fams =  synteny.split(/\s+/);
    var xfam = d.x;
    xfam = x0Synteny+maxX + 40*numberMaxFam ;
    var yfam = d.y -10; // cf pour syntheLeft
    fams.forEach (function (d,i){
      var famcds = d.split(/:/);
      var nomFam = famcds[0];
      var cds = "none";
      if (famcds.length > 0) {
        cds = famcds[1];
      }
      var sens = 1;
      if (nomFam.substring(0,1) === "-") {
        sens = -1;
        nomFam = nomFam.substring(1);
      };
      if (nomFam.substring(0,1) === "+") {
        nomFam = nomFam.substring(1);
      };
      var locnode = {x:xfam + (i+2)*40,y: yfam,nfam:nomFam,sens:sens,cds:cds};
      dataset.push(locnode);
      families.push(nomFam);
    });
  });
  // =====================================
  // Creation jeu de donnes blocs centraux
  // =====================================
  leaves.forEach (function (d,i ){
    var xfam = x0Synteny+maxX + 40*numberMaxFam ;
    var yfam = d.y;
    var seqdef ="";
    if (d.data.lastEvent.defintiion !== undefined) {
      seqdef=d.data.lastEvent.defintiion;
    }
    var locnode;
    if (typeof d.data.name === "string") {
      locnode = {x:xfam+ (1)*40,y: yfam-10,nfam:""+d.data.name+" "+seqdef};
    }
    else {
      locnode = {x:xfam+ (1)*40,y: yfam-10,nfam:"collapsed"};
    }
    centralDataset.push(locnode);
  });
  var allFamilies = families;
  var uniqueFamilies = removesortDuplicates(removeSingle(families));
  uniqueFamilies.push("---");
  // =======================================
  // D3:       Objets BLOCS DE SYNTENIE
  // =======================================
  var block =
    g.selectAll(".block")
    .data(dataset);
  //EXIT
  block.exit().remove();
  //ENTER
  var blockEnter =
    block
    .enter()
    .append("g")
    .attr("class", "block");
  //ENTER + UPDATE
  blockEnter
    .merge(block)
    .attr("transform",function(d) {
      var transx = d.x;
      var transy = d.y;
      return "translate("+transx+", "+transy+")";
    })
    .append("rect")
    .attr("width", "37px")
    .attr("height", "14px")
    .style("fill", "white")
  blockEnter
    .merge(block)
    .attr("transform",function(d) {
        var transx = d.x;
        var transy = d.y;
        return "translate("+transx+", "+transy+")";
      })
    .append("a")
    .append("polyline")
    .attr("points",function(d) {
      if (d.sens < 0) {
        return "3,7,8,2,34,2,34,12,8,12,3,7";
      }
      else {
        return   "3,2,30,2,34,7,30,12,3,12,3,2"
      }
    })
    .style("stroke-width","3")
    .style("fill",  function (d) {
      if (d.nfam === "ORPHAN") {
        return "grey"
      }
      if  ( (d.nfam.substring(0,8)) === "COREONLY") {
        return "white"
      }
      if  (uniqueFamilies.indexOf(d.nfam) === -1 ) {
        return "white"
      }
      return color(uniqueFamilies.indexOf(d.nfam))
    })
    .style("fill-opacity",function (d) {
      var index = uniqueFamilies.indexOf(d.nfam);
      if ((index >= 0) && (index < 20)) {
        return "0.9"
      }
      if ((index >= 20) && (index < 40)) {
        return "0.6"
      }
      if ((index >= 40) && (index < 1000)) {
        return "0.4"
      }
    })
    .style("stroke",function (d) {
      if (d.nfam === "ORPHAN") {
        return "white"
      }
      if  (uniqueFamilies.indexOf(d.nfam) === -1 ) {
        return "black"
      }
      else {
        return color(uniqueFamilies.indexOf(d.nfam)+10)
      }
    })
    .style("stroke-dasharray",function (d) {
      if  ( (d.nfam.substring(0,8)) === "COREONLY") {
          return ("2")
      }
    })
    .on('mouseover',function (d){
      if ((d.nfam !== "ORPHAN") && (d.nfam.substring(0,8) !== "COREONLY")) {
        var sel1 =g.selectAll("polyline").filter(function(e) { return e.nfam === d.nfam; });
         sel1.style("stroke-width","3")
          sel1.style("stroke","rgb(0,0,0)")
      }
      if  (d.nfam.substring(0,8) === "COREONLY") {
        var sel1 =g.selectAll("polyline").filter(function(e) { return e.nfam === d.nfam; });
        sel1.style("stroke-dasharray","0")
      }
    })
    .on('mouseout',function (d){
      if ((d.nfam !== "ORPHAN") && (d.nfam.substring(0,8) !== "COREONLY")) {
        var sel1 =g.selectAll("polyline").filter(function(e) { return e.nfam === d.nfam; });
        sel1.style("stroke-width","3")
        sel1.style("stroke",function (d) {
          if (uniqueFamilies.indexOf(d.nfam) === -1 ) {
            return "black"
          }
          else {
            return color(uniqueFamilies.indexOf(d.nfam)+10)
          }
        })
      }
      if  (d.nfam.substring(0,8) === "COREONLY") {
        var sel1 =g.selectAll("polyline").filter(function(e) { return e.nfam === d.nfam; });
        sel1.style("stroke-dasharray","2")
      }
    });
  blockEnter
    .merge(block)
    .attr("transform",function(d) {
      var transx = d.x;
      var transy = d.y;
      return "translate("+transx+", "+transy+")";
    })
    .on('mouseover',function (d){
      div.transition()
        .duration(200)
        .style("opacity", .9);
      div.html(function() {
          if  ((d.nfam.substring(0,8)) === "COREONLY") {
            return "<b>[JUMP TO CORE] "+d.nfam.substring(9)+"</b> ("+d.cds+")";
          }
          var seqdef = d.cds.split("|");
          if (seqdef.length > 1) {
            return "<b>"+d.nfam+"</b><br> ("+seqdef[0]+")<br>"+seqdef[1].replace(/_/g," ");
          }
          return "<b>"+d.nfam+"</b> ("+d.cds+")";
        })
        .style("left", (d3.event.pageX) + "px")
        .style("top", (d3.event.pageY - 28) + "px");
      })
      .on('mouseout',function (d){
        div.transition()
          .duration(500)
          .style("opacity", 0);
      });
  // ====================================
  //         Objet BARRE CENTRALE
  // ====================================
  var dataBarre = [{x: x0Synteny+ maxX+(numberMaxFam+1)*41-5,y: minY-5,h:maxY-minY+15}];
  var barre = g.selectAll(".barre")
    .data(dataBarre);
  //EXIT
  barre.exit().remove();
  //ENTER
  var barreEnter =
    barre
    .enter()
    .append("rect")
    .attr("class", "barre");
  //ENTER + UPDATE
  barreEnter
    .merge(barre)
    .attr("transform",function(d) {
          var transx = d.x;
          var transy = d.y;
          return "translate("+transx+", "+transy+")";
        })
    .attr("width", "30px")
    .attr("height", function(d){
      var hauteur = d.h;
      return hauteur+"px";
    })
    .style("stroke-width","3")
    .style("fill", 'rgba(255, 0, 0, 0.1)');
  // ===================================
  // Objets  BLOCS CENTRAUX
  // ===================================
  var centralBlock =
    g.selectAll(".cblock")
    .data(centralDataset);
  //EXIT
  centralBlock.exit().remove();
  //ENTER
  var centralBlockEnter =
    centralBlock
    .enter()
    .append("g")
    .attr("class", "cblock");
  //ENTER + UPDATE
  centralBlockEnter
    .merge(centralBlock)
    .attr("transform",function(d) {
      var transx = d.x;
      var transy = d.y;
      return "translate("+transx+", "+transy+")";
    })
    .append("polyline")
    .attr("points", "3,2,30,2,34,7,30,12,3,12,3,2")
    .style("stroke-width","3")
    .style("fill", "black")
    .style("stroke","grey")
    .on('mouseover',function (d){
      div.transition()
      .duration(200)
      .style("opacity", .9);
      div.html(function() {
        var buf = d.nfam.split(" ");
        var defcds = buf.shift();
        return "<b>"+defcds+"</b><br>"+buf.join(" ");
        })
      .style("left", (d3.event.pageX) + "px")
      .style("top", (d3.event.pageY - 28) + "px");
    })
    .on('mouseout',function (d){});
  // -------------------------------------------------------
  // Centre sue la sequence requete lors du premier chargement
  // ---------------------------------------------------------
  if (firstLoad === 1 ) {
    $( "div.demo" )
    .animate({scrollTop: -minY + scrollref},(2000 + Math.abs(-minY +scrollref)/500),function() {});
    }
  }
  // Fin de la fonction updateSvg
  // =============================

  // ACtions sur les boutons
  // -----------------------

  $('#display a').on( 'click', function( event ) {
    var $target = $( event.currentTarget ),
    val = $target.attr( 'data-value' ),
    $inp = $target.find( 'input' ),
    idx;
    if ( ( idx = options.indexOf( val ) ) > -1 ) {
      options.splice( idx, 1 );
      setTimeout( function() { $inp.prop( 'checked', false ) }, 0);
    }
    else {
      options.push( val );
      setTimeout( function() { $inp.prop( 'checked', true ) }, 0);
    }
    $( event.target ).blur();
    myStorage.setItem("options",options);
    updateLayout(cladeRoot);
    return false;
  });

  $('#display a').ready(function() {
    stringOptions = myStorage.getItem("options");
    if (stringOptions != null) {
      options = stringOptions.split(",");
      options.forEach(function (o) {
        $('#'+o).attr('checked',true);
      });
    }
  });

  $('#selectCrossref').on('click', function(event) {
    selectedCrossref=$( "#selectCrossref option:selected" ).text();
    selectedCrossrefURL=crossref[selectedCrossref].url;
    myStorage.setItem("crossref",selectedCrossref);
    updateLayout(cladeRoot);
  });

  $('#selectCrossref').ready(function() {
      // selectedCrossref="HOGENOM";
    });

  $('#action').ready(function() {
    switch (myStorage.getItem("action")) {
      case "Switch children":
        $('#switch').css('color','red');
        break;
      case "Collapse/Expand":
        $('#collapse').css('color','red');
        break;
      case "Sub Tree/Upper Tree":
        $('#subtree').css('color','red');
        break;
      default:
    }
  });

  $('#action').on('click', function(event, dropdownData) {
    var target = event.toElement || event.relatedTarget || event.target || function () { throw "Failed to attach an event target!"; }
    myStorage.setItem("action",target.text);
    switch (target.text) {
      case "Switch children":
        action = svgEvents.switchChildren;
        $('#switch').css('color','red');
        $('#collapse').css('color','black');
        $('#subtree').css('color','black');
        updateLayout(cladeRoot);
        break;
      case "Collapse/Expand":
        action = svgEvents.collapse;
        $('#switch').css('color','black');
        $('#collapse').css('color','red');
        $('#subtree').css('color','black');
        updateLayout(cladeRoot);
        break;
      case "Sub Tree/Upper Tree":
        action = svgEvents.focus;
        $('#switch').css('color','black');
        $('#collapse').css('color','black');
        $('#subtree').css('color','red');
        updateLayout(cladeRoot);
        break;
      default:
    }
  });

  $('#globalcollapse').on('click', function(event, dropdownData) {
    treeRoot = d3.hierarchy(cladeRoot, function(d) {
      return d.clade;
    });
    collapseVeryBigTree(treeRoot,patterns);
    updateLayout(cladeRoot);
  });

  $('#globalexpand').on('click', function(event, dropdownData) {
    treeRoot = d3.hierarchy(cladeRoot, function(d) {
      return d.clade;
    });
    expandTree(treeRoot);
    updateLayout(cladeRoot);
  });

  var step = 10;

  $('#moreWidth').on('click', function(event, dropdownData) {
    nodeWidth += step;
    myStorage.setItem("width",nodeWidth);
    updateLayout(cladeRoot);
  });

  $('#lessWidth').on('click', function(event, dropdownData) {
    nodeWidth -= step;
    if  (nodeWidth  < step ) {
      nodeWidth = step;
    }
    myStorage.setItem("width",nodeWidth);
    updateLayout(cladeRoot);
  });

  $('#moreHeigth').on('click', function(event, dropdownData) {
    nodeHeigth += step;
    updateLayout(cladeRoot);
  });

  $('#lessHeigth').on('click', function(event, dropdownData) {
    nodeHeigth -= step;
    if  (nodeHeigth  < 0 ) {
      nodeHeigth = 1;
    }
    updateLayout(cladeRoot);
  });

  $('#goLeft').on('click', function(event, dropdownData) {
    x0Synteny -= 100;
    updateLayout(cladeRoot);
  });

  $('#goRight').on('click', function(event, dropdownData) {
    x0Synteny += 100;
    updateLayout(cladeRoot);
  });

  $('#export').on('click', function() {
    saveSVG();
  });

</script>
</html>
